name: Deploy SkillBridge (EKS + API Gateway)

on:
    push:
        branches: [develop]

env:
    AWS_REGION: ap-southeast-1
    STACK_NAME: skillbridge-stack
    IMAGE_TAG: latest
    SECRET_NAME: MongoDBConnection

jobs:
    deploy:
        runs-on: ubuntu-latest

        steps:
            - name: üßæ Checkout Repository
              uses: actions/checkout@v4

            - name: ‚öôÔ∏è Configure AWS Credentials
              uses: aws-actions/configure-aws-credentials@v4
              with:
                  aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
                  aws-region: ${{ env.AWS_REGION }}

            - name: üîç Debug AWS Identity
              run: |
                  echo "üîë Verifying AWS credentials..."
                  aws sts get-caller-identity
                  echo "‚úÖ AWS credentials verified."

            - name: üß± Docker Login to ECR
              run: |
                  echo "üîê Logging into ECR..."
                  aws ecr get-login-password --region $AWS_REGION | docker login \
                    --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.$AWS_REGION.amazonaws.com
                  echo "‚úÖ Docker authenticated with ECR."

            - name: üßπ Clean Up Failed or Stuck Stacks
              run: |
                  echo "üîç Checking current CloudFormation stack status for: $STACK_NAME ..."
                  STATUS=$(aws cloudformation describe-stacks \
                    --stack-name $STACK_NAME --region $AWS_REGION \
                    --query "Stacks[0].StackStatus" --output text 2>/dev/null || echo "NONE")

                  echo "‚ÑπÔ∏è Stack status detected: $STATUS"

                  # Match any rollback, delete failed, or create failed state
                  if [[ "$STATUS" =~ "ROLLBACK" || "$STATUS" =~ "DELETE_FAILED" || "$STATUS" == "CREATE_FAILED" ]]; then
                    echo "‚ö†Ô∏è Stack $STACK_NAME is in a failed state ($STATUS). Preparing cleanup..."
                    
                    echo "üßæ Recent failure reasons:"
                    aws cloudformation describe-stack-events \
                      --stack-name $STACK_NAME \
                      --region $AWS_REGION \
                      --query "StackEvents[?ResourceStatus=='CREATE_FAILED' || ResourceStatus=='DELETE_FAILED'].[LogicalResourceId,ResourceStatusReason]" \
                      --output table || echo "‚ö†Ô∏è Unable to retrieve stack events."

                    echo "üß® Deleting stuck stack..."
                    aws cloudformation delete-stack --stack-name $STACK_NAME --region $AWS_REGION || true
                    echo "‚è≥ Waiting for stack deletion to complete..."
                    aws cloudformation wait stack-delete-complete --stack-name $STACK_NAME --region $AWS_REGION || true
                    echo "‚úÖ Cleanup complete. Stack deleted or fully cleared."

                  elif [[ "$STATUS" == "DELETE_IN_PROGRESS" || "$STATUS" == "CREATE_IN_PROGRESS" ]]; then
                    echo "‚è≥ Stack is currently in progress ($STATUS). Waiting 30 seconds..."
                    sleep 30
                    aws cloudformation wait stack-delete-complete --stack-name $STACK_NAME --region $AWS_REGION || true
                    echo "‚úÖ Stack deletion finished after wait."

                  else
                    echo "‚úÖ Stack status is $STATUS ‚Äî no cleanup needed."
                  fi

            # - name: üß∞ Ensure ECR Repositories Exist
            #   run: |
            #       set -e
            #       declare -a repos=("user-service" "booking-service" "availability-service" "search-service")
            #       for repo in "${repos[@]}"; do
            #         echo "üß© Checking ECR repo: $repo"
            #         if aws ecr describe-repositories --repository-names $repo --region $AWS_REGION >/dev/null 2>&1; then
            #           echo "‚úÖ Repository '$repo' already exists."
            #         else
            #           echo "üöÄ Creating ECR repository '$repo'..."
            #           aws ecr create-repository --repository-name $repo --region $AWS_REGION
            #         fi
            #       done
            #       echo "‚úÖ All ECR repositories are ready."

            - name: ‚òÅÔ∏è Deploy CloudFormation (VPC + EKS + ECR)
              run: |
                  echo "üöß Deploying CloudFormation stack: $STACK_NAME ..."
                  aws cloudformation deploy \
                    --stack-name $STACK_NAME \
                    --template-file cloudformation/main.yaml \
                    --capabilities CAPABILITY_NAMED_IAM \
                    --no-fail-on-empty-changeset \
                    --region $AWS_REGION \
                    --debug
                  echo "‚úÖ CloudFormation stack deployed successfully."

            - name: üõ†Ô∏è Build & Push Docker Images
              run: |
                  set -e
                  declare -a services=("user-service" "booking-service" "availability-service" "search-service")
                  for s in "${services[@]}"; do
                    echo "üß± Building image for $s..."
                    docker build -t $s ./services/$s
                    echo "üîÑ Tagging image for ECR..."
                    docker tag $s:latest ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.$AWS_REGION.amazonaws.com/$s:${IMAGE_TAG}
                    echo "üì§ Pushing image to ECR..."
                    docker push ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.$AWS_REGION.amazonaws.com/$s:${IMAGE_TAG}
                    echo "‚úÖ Successfully built and pushed $s"
                  done

            - name: üîÑ Update Kubeconfig
              run: |
                  echo "üì° Fetching EKS Cluster name from CloudFormation..."
                  CLUSTER=$(aws cloudformation describe-stacks --stack-name $STACK_NAME \
                    --query "Stacks[0].Outputs[?OutputKey=='ClusterName'].OutputValue" --output text)
                  echo "üß© Cluster detected: $CLUSTER"
                  aws eks update-kubeconfig --name $CLUSTER --region $AWS_REGION
                  echo "‚úÖ kubeconfig updated successfully."

            - name: üß† Verify Cluster Connection
              run: |
                  echo "üîç Checking if cluster is reachable..."
                  kubectl cluster-info
                  kubectl get nodes -o wide || echo "‚ö†Ô∏è Could not list nodes yet (cluster still initializing)."

            - name: üèóÔ∏è Create Namespace
              run: |
                  echo "üìÅ Creating namespace skillbridge (if not exists)..."
                  kubectl get ns skillbridge || kubectl create ns skillbridge
                  echo "‚úÖ Namespace ready."

            - name: üîë Fetch Mongo URI from AWS Secrets Manager
              id: mongo
              run: |
                  echo "üîê Fetching secret from Secrets Manager: $SECRET_NAME"
                  RAW_JSON=$(aws secretsmanager get-secret-value \
                    --secret-id "$SECRET_NAME" \
                    --query SecretString --output text)
                  URI=$(echo "$RAW_JSON" | jq -r '.MONGODB_URI')
                  if [ -z "$URI" ]; then
                    echo "‚ùå Failed to extract MONGODB_URI from secret!"
                    exit 1
                  fi
                  echo "‚úÖ Retrieved Mongo URI: [REDACTED]"
                  kubectl -n skillbridge delete secret mongodb-uri --ignore-not-found
                  kubectl -n skillbridge create secret generic mongodb-uri --from-literal=MONGODB_URI="$URI"
                  echo "‚úÖ MongoDB secret created successfully in Kubernetes."
                  echo "uri=$URI" >> $GITHUB_OUTPUT

            - name: üß© Apply Service Manifests
              env:
                  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
              run: |
                  echo "üöÄ Applying Kubernetes manifests..."
                  sed "s|\${AWS_ACCOUNT_ID}|${AWS_ACCOUNT_ID}|g" k8s/services-deployments.yaml | kubectl apply -f -
                  kubectl get pods -n skillbridge
                  echo "‚úÖ Services deployed successfully."

            - name: üåê Deploy Edge Nginx
              run: |
                  echo "üß≠ Deploying edge Nginx gateway..."
                  kubectl apply -f k8s/edge-nginx-configmap.yaml
                  kubectl apply -f k8s/edge-nginx-deployment.yaml
                  kubectl get svc -n skillbridge
                  echo "‚úÖ Edge Nginx deployment applied."

            - name: ‚è≥ Wait for LoadBalancer & Capture DNS
              id: edge
              run: |
                  echo "üïí Waiting for edge LoadBalancer hostname..."
                  for i in {1..60}; do
                    DNS=$(kubectl -n skillbridge get svc edge-nginx -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
                    if [ -n "$DNS" ]; then
                      echo "üåê LoadBalancer available: $DNS"
                      echo "dns=$DNS" >> $GITHUB_OUTPUT
                      exit 0
                    fi
                    echo "‚è≥ Waiting for ELB to be provisioned... ($i/60)"
                    sleep 10
                  done
                  echo "‚ùå LoadBalancer not ready after 10 minutes."
                  kubectl describe svc edge-nginx -n skillbridge
                  exit 1

            - name: ‚òÅÔ∏è Deploy API Gateway
              run: |
                  BASE_URL="http://${{ steps.edge.outputs.dns }}"
                  echo "üöÄ Deploying API Gateway with base URL: $BASE_URL"
                  aws cloudformation deploy \
                    --stack-name ${STACK_NAME}-apigw \
                    --template-file cloudformation/apigateway.yaml \
                    --parameter-overrides IntegrationBaseUrl="$BASE_URL" \
                    --capabilities CAPABILITY_NAMED_IAM \
                    --no-fail-on-empty-changeset \
                    --debug
                  echo "‚úÖ API Gateway stack deployed."

            - name: üîó Show API Endpoint
              run: |
                  echo "üîç Fetching API Gateway endpoint..."
                  API=$(aws cloudformation describe-stacks --stack-name ${STACK_NAME}-apigw \
                      --query "Stacks[0].Outputs[?OutputKey=='ApiEndpoint'].OutputValue" --output text)
                  echo "‚úÖ API Gateway endpoint is: $API"
